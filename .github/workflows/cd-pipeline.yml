name: Continuous Deployment Pipeline

on:
  push:
    branches:
      - develop
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'main' && 'production' || 'staging' }}
    env:
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
      ECR_REPOSITORY: repo
      IMAGE_TAG: latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          role-session-name: GitHubActions
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push the Docker image
        run: |
          docker build -t ${{env.ECR_REGISTRY}}:${{env.IMAGE_TAG}} .
          docker tag ${{env.ECR_REGISTRY}}:${{env.IMAGE_TAG}} ${{env.ECR_REGISTRY}}/${{env.ECR_REPOSITORY}}:${{env.IMAGE_TAG}}
          docker push ${{env.ECR_REGISTRY}}/${{env.ECR_REPOSITORY}}:${{env.IMAGE_TAG}}

      - name: Register new task definition
        id: task_definition
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ github.ref_name == 'main' && 'ecs/task-definition-production.json' || 'ecs/task-definition-staging.json' }}
          container-name: app
          image: ${{env.ECR_REGISTRY}}/${{env.ECR_REPOSITORY}}:${{env.IMAGE_TAG}}

      - name: Deploy to ECS service
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          cluster: ${{ secrets.ECS_CLUSTER_NAME }}
          service: ${{ secrets.ECS_SERVICE_NAME }}
          task-definition: ${{ steps.task_definition.outputs.task-definition }}
          wait-for-service-stability: true

      - name: Notify Slack when job failed
        if: ${{ failure() }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          payload: |
            {
              "url": "${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
            }
          webhook: ${{ secrets.SLACK_WEBHOOK_URL_BACKEND }}
          webhook-type: webhook-trigger

  db-migration:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'main' && 'production' || 'staging' }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Determine base branch and previous commit
        id: determine_branch
        run: |
          BASE_BRANCH="${{ github.ref_name }}"
          git fetch origin $BASE_BRANCH
          PREVIOUS_COMMIT=$(git rev-parse origin/$BASE_BRANCH~1)
          echo "PREVIOUS_COMMIT=$PREVIOUS_COMMIT" >> $GITHUB_ENV
          echo "BASE_BRANCH=$BASE_BRANCH" >> $GITHUB_ENV

      - name: Check for changes in app/infra/alembic/versions
        id: check_changes
        run: |
          if git diff --quiet $PREVIOUS_COMMIT HEAD -- app/infra/alembic/versions; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "No changes detected in app/infra/alembic/versions. Skipping DB migration."
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        if: steps.check_changes.outputs.no_changes == 'false'
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          role-session-name: GitHubActions
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Cache Poetry dependencies
        if: steps.check_changes.outputs.no_changes == 'false'
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Set up Python
        if: steps.check_changes.outputs.no_changes == 'false'
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Poetry
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo 'export PATH="$HOME/.local/bin:$PATH"' >> $GITHUB_ENV
          source $GITHUB_ENV

      - name: Set up Python environment
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          poetry install

      - name: Set up SSH key
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "${{ secrets.BASTION_HOST }}" > ~/.ssh/known_hosts
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          BASTION_HOST: ${{ secrets.BASTION_HOST }}

      - name: Start SSH port forwarding
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          ssh -o StrictHostKeyChecking=no -fN -i ~/.ssh/id_rsa -L 5432:${{ secrets.DB_HOST }}:5432 ${{ secrets.SSH_USER }}@${{ secrets.BASTION_HOST }} > ssh_output.log 2>&1 || true
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          BASTION_HOST: ${{ secrets.BASTION_HOST }}

      - name: Run Alembic database migration
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          poetry run alembic upgrade head
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: localhost
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}

      - name: Clean up SSH session
        if: steps.check_changes.outputs.no_changes == 'false'
        run: |
          pkill -f "ssh -o StrictHostKeyChecking=no"

      - name: Notify Slack when job failed
        if: ${{ failure() }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          payload: |
            {
              "url": "${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
            }
          webhook: ${{ secrets.SLACK_WEBHOOK_URL_BACKEND }}
          webhook-type: webhook-trigger
